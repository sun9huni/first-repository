# -*- coding: utf-8 -*-
"""D.I.V.E. AI ì •ì°© ì‹œë®¬ë ˆì´í„° (Python) - ì•ˆì •í™” ë²„ì „

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nkQHoZ4QQ1kSN3UL8cE6YmUaYPrlkUsG
"""

pip! install streamlit pandas plotly requests

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import requests
import json

# ---------------------------------
# ë°ì´í„° ë¡œë“œ (ê°€ìƒ ë°ì´í„°)
# ---------------------------------
@st.cache_data
def load_data():
    region_data = [
        { 'id': 'A', 'name': 'ê°•ì›ë„ ê°•ë¦‰ì‹œ', 'budget': 280, 'job_tags': ['local', 'digital'], 'community': 4, 'scores': { 'ë¹„ìš©': 3, 'ì¼ìë¦¬': 4, 'ì»¤ë®¤ë‹ˆí‹°': 4, 'ì ‘ê·¼ì„±': 3, 'ë¬¸í™”/ì—¬ê°€': 4 } },
        { 'id': 'B', 'name': 'ì „ë¼ë¶ë„ ì „ì£¼ì‹œ', 'budget': 220, 'job_tags': ['local', 'public'], 'community': 5, 'scores': { 'ë¹„ìš©': 4, 'ì¼ìë¦¬': 3, 'ì»¤ë®¤ë‹ˆí‹°': 5, 'ì ‘ê·¼ì„±': 4, 'ë¬¸í™”/ì—¬ê°€': 5 } },
        { 'id': 'C', 'name': 'ì œì£¼íŠ¹ë³„ìì¹˜ë„ ì œì£¼ì‹œ', 'budget': 350, 'job_tags': ['digital', 'local'], 'community': 4, 'scores': { 'ë¹„ìš©': 2, 'ì¼ìë¦¬': 5, 'ì»¤ë®¤ë‹ˆí‹°': 4, 'ì ‘ê·¼ì„±': 3, 'ë¬¸í™”/ì—¬ê°€': 5 } },
        { 'id': 'D', 'name': 'ê²½ìƒë¶ë„ ì•ˆë™ì‹œ', 'budget': 180, 'job_tags': ['local', 'public'], 'community': 3, 'scores': { 'ë¹„ìš©': 5, 'ì¼ìë¦¬': 2, 'ì»¤ë®¤ë‹ˆí‹°': 3, 'ì ‘ê·¼ì„±': 2, 'ë¬¸í™”/ì—¬ê°€': 4 } },
        { 'id': 'E', 'name': 'ì „ë¼ë‚¨ë„ ìˆœì²œì‹œ', 'budget': 200, 'job_tags': ['local', 'public'], 'community': 4, 'scores': { 'ë¹„ìš©': 4, 'ì¼ìë¦¬': 3, 'ì»¤ë®¤ë‹ˆí‹°': 4, 'ì ‘ê·¼ì„±': 3, 'ë¬¸í™”/ì—¬ê°€': 4 } },
        { 'id': 'F', 'name': 'ì¶©ì²­ë‚¨ë„ ê³µì£¼ì‹œ', 'budget': 190, 'job_tags': ['public', 'local'], 'community': 3, 'scores': { 'ë¹„ìš©': 4, 'ì¼ìë¦¬': 2, 'ì»¤ë®¤ë‹ˆí‹°': 3, 'ì ‘ê·¼ì„±': 3, 'ë¬¸í™”/ì—¬ê°€': 3 } },
        { 'id': 'G', 'name': 'ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ', 'budget': 400, 'job_tags': ['public', 'digital'], 'community': 2, 'scores': { 'ë¹„ìš©': 2, 'ì¼ìë¦¬': 5, 'ì»¤ë®¤ë‹ˆí‹°': 2, 'ì ‘ê·¼ì„±': 5, 'ë¬¸í™”/ì—¬ê°€': 4 } },
        { 'id': 'H', 'name': 'ê²½ìƒë‚¨ë„ ë‚¨í•´êµ°', 'budget': 150, 'job_tags': ['local'], 'community': 5, 'scores': { 'ë¹„ìš©': 5, 'ì¼ìë¦¬': 2, 'ì»¤ë®¤ë‹ˆí‹°': 5, 'ì ‘ê·¼ì„±': 1, 'ë¬¸í™”/ì—¬ê°€': 2 } },
    ]

    job_data = [
        { 'id': 1, 'name': 'ê°•ë¦‰ì‹œ ê´€ê´‘ ìŠ¤íƒ€íŠ¸ì—… ë§ˆì¼€í„°', 'type': 'local', 'region_id': 'A', 'base_score': 92 },
        { 'id': 2, 'name': 'ì „ì£¼ì‹œ í•œì˜¥ë§ˆì„ ì½˜í…ì¸  ê¸°íšì', 'type': 'local', 'region_id': 'B', 'base_score': 95 },
        { 'id': 3, 'name': 'ì œì£¼ì‹œ ITê¸°ì—… ì›ê²©ê·¼ë¬´ ê°œë°œì', 'type': 'digital', 'region_id': 'C', 'base_score': 98 },
        { 'id': 4, 'name': 'ì•ˆë™ì‹œ ìœ êµë¬¸í™” ë””ì§€í„¸ ì•„ì¹´ì´ë¸Œ êµ¬ì¶•', 'type': 'public', 'region_id': 'D', 'base_score': 88 },
        { 'id': 5, 'name': 'ìˆœì²œë§Œêµ­ê°€ì •ì› ìŠ¤ë§ˆíŠ¸íŒœ ìš´ì˜ìš”ì›', 'type': 'local', 'region_id': 'E', 'base_score': 91 },
        { 'id': 6, 'name': 'ê³µì£¼ì‹œ ë°±ì œë¬¸í™”ìœ ì‚° VR/AR ê°œë°œ', 'type': 'public', 'region_id': 'F', 'base_score': 85 },
        { 'id': 7, 'name': 'ì„¸ì¢…ì‹œ ì •ë¶€ì²­ì‚¬ IT í–‰ì •ë³´ì¡°', 'type': 'public', 'region_id': 'G', 'base_score': 90 },
        { 'id': 8, 'name': 'ë‚¨í•´êµ° ê·€ë†ê·€ì´Œ ì§€ì›ì„¼í„° ì½”ë””ë„¤ì´í„°', 'type': 'local', 'region_id': 'H', 'base_score': 89 },
        { 'id': 9, 'name': 'ì›ê²© ê·¼ë¬´ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œì', 'type': 'digital', 'region_id': None, 'base_score': 95 },
        { 'id': 10, 'name': 'ì›ê²© ê·¼ë¬´ UI/UX ë””ìì´ë„ˆ', 'type': 'digital', 'region_id': None, 'base_score': 92 },
        { 'id': 11, 'name': 'ì›ê²© ê·¼ë¬´ í¼í¬ë¨¼ìŠ¤ ë§ˆì¼€í„°', 'type': 'digital', 'region_id': None, 'base_score': 88 },
    ]

    benefits_data = [
        { 'id': 1, 'region_id': 'A', 'category': 'ì²­ë…„', 'name': 'ê°•ë¦‰ì‹œ ì²­ë…„ ì›”ì„¸ ì§€ì›', 'description': 'ì›” ìµœëŒ€ 20ë§Œì›, 12ê°œì›”ê°„ ì£¼ê±° ì„ì°¨ë£Œ ì§€ì›' },
        { 'id': 2, 'region_id': 'A', 'category': 'ì°½ì—…', 'name': 'ë¡œì»¬í¬ë¦¬ì—ì´í„° ìœ¡ì„± ì§€ì›', 'description': 'ì§€ì—­ìì› í™œìš© ì°½ì—… ì•„ì´í…œ ì‚¬ì—…í™” ìê¸ˆ ìµœëŒ€ 5ì²œë§Œì› ì§€ì›' },
        { 'id': 3, 'region_id': 'B', 'category': 'ì²­ë…„', 'name': 'ì „ì£¼ì²­ë…„ ìƒìƒ(ç›¸ç”Ÿ)ì¹´ë“œ', 'description': 'ë¯¸ì·¨ì—… ì²­ë…„ì—ê²Œ ì›” 30ë§Œì› í™œë™ë¹„ ì§€ì›' },
        { 'id': 4, 'region_id': 'B', 'category': 'ì£¼ê±°', 'name': 'ì‹ í˜¼ë¶€ë¶€ ì£¼íƒ ì „ì„¸ìê¸ˆ ëŒ€ì¶œì´ì ì§€ì›', 'description': 'ì „ì„¸ìê¸ˆ ëŒ€ì¶œ ì”ì•¡ì˜ 1.2% ì§€ì›' },
        { 'id': 5, 'region_id': 'C', 'category': 'ì£¼ê±°', 'name': 'ì œì£¼í˜• ì²­ë…„ ì£¼ê±°ë³´ì¥ ì •ì±…', 'description': 'í–‰ë³µì£¼íƒ, ì£¼ê±°ë¹„ ì§€ì› ë“± ë‹¤ì–‘í•œ ì£¼ê±° ì •ì±… ì œê³µ' },
        { 'id': 6, 'region_id': 'C', 'category': 'ì°½ì—…', 'name': 'ì œì£¼ í…Œí¬ë…¸íŒŒí¬ ì…ì£¼ê¸°ì—… ì§€ì›', 'description': 'ì‚¬ë¬´ê³µê°„, R&D, ë§ˆì¼€íŒ… ë“± ì¢…í•© ì§€ì›' },
        { 'id': 7, 'region_id': 'D', 'category': 'ì£¼ê±°', 'name': 'ê·€ë†ì¸ ì •ì°©ì¥ë ¤ê¸ˆ ì§€ì›', 'description': 'ì„¸ëŒ€ë‹¹ 30ë§Œì›/ì›”, ìµœëŒ€ 2ë…„ê°„ ì§€ì›' },
        { 'id': 8, 'region_id': 'E', 'category': 'ì²­ë…„', 'name': 'ìˆœì²œì‹œ ì²­ë…„ ì í”„ì—… í”„ë¡œì íŠ¸', 'description': 'ì²­ë…„ êµ¬ì§ì ì—­ëŸ‰ê°•í™” êµìœ¡ ë° ì·¨ì—…ì—°ê³„ ì§€ì›' },
        { 'id': 9, 'region_id': 'F', 'category': 'ìœ¡ì•„', 'name': 'ê³µì£¼ì‹œ ì¶œì‚°ì¥ë ¤ê¸ˆ', 'description': 'ì²«ì§¸ 300ë§Œì›, ë‘˜ì§¸ 500ë§Œì›, ì…‹ì§¸ ì´ìƒ 1,000ë§Œì› ì§€ì›' },
        { 'id': 10, 'region_id': 'G', 'category': 'ìœ¡ì•„', 'name': 'ì„¸ì¢…ì‹œ ê³µë™ìœ¡ì•„ë‚˜ëˆ”í„°', 'description': 'ì¥ë‚œê° ëŒ€ì—¬ ë° ìœ¡ì•„ í’ˆì•—ì´ ì»¤ë®¤ë‹ˆí‹° ê³µê°„ ì œê³µ' },
        { 'id': 11, 'region_id': 'H', 'category': 'ì£¼ê±°', 'name': 'ë‚¨í•´êµ° ê·€ë†ì¸ì˜ ì§‘', 'description': 'ì €ë ´í•œ ì„ëŒ€ë£Œë¡œ ì„ì‹œ ê±°ì£¼ê³µê°„ ì œê³µ' },
    ]
    return pd.DataFrame(region_data), pd.DataFrame(job_data), pd.DataFrame(benefits_data)

region_df, job_df, benefits_df = load_data()

# ---------------------------------
# Streamlit ì•± UI êµ¬ì„±
# ---------------------------------

st.set_page_config(layout="wide", page_title="D.I.V.E - AI ì •ì°© ì‹œë®¬ë ˆì´í„°")

# --- íƒ€ì´í‹€ ---
st.title("D.I.V.E - AI ì •ì°© ì‹œë®¬ë ˆì´í„° ğŸ§­")
st.markdown("ë°ì´í„°ì™€ AIë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‹¹ì‹ ì—ê²Œ ê°€ì¥ ì í•©í•œ ì •ì°©ì§€ë¥¼ ì˜ˆì¸¡í•´ë³´ì„¸ìš”.")

# --- ì‚¬ì´ë“œë°”: ì‚¬ìš©ì ì…ë ¥ ---
with st.sidebar:
    st.header("ë‚˜ì˜ ì •ì°© ì¡°ê±´ ì„¤ì •í•˜ê¸°")
    budget = st.slider("ì›” ê°€ìš© ì˜ˆì‚° (ë§Œì›)", 100, 500, 200, 10)
    job_type_display = st.selectbox("í¬ë§ ì§ë¬´ ìœ í˜•", ('ë””ì§€í„¸/ì›ê²©', 'ì§€ì—­ ê¸°ë°˜(ë†ì—…/ê´€ê´‘)', 'ê³µê³µ/ì‚¬íšŒì„œë¹„ìŠ¤'))
    community_labels = ['ë§¤ìš° ë‚®ìŒ', 'ë‚®ìŒ', 'ì¤‘ê°„', 'ë†’ìŒ', 'ë§¤ìš° ë†’ìŒ']
    community_display = st.select_slider("ì»¤ë®¤ë‹ˆí‹° ì„ í˜¸ë„", options=community_labels, value='ì¤‘ê°„')

    st.divider()

    st.header("API ì„¤ì •")
    api_key = st.text_input("Google Gemini API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", type="password", help="AI ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.")

    # ë‚´ë¶€ ê°’ ë³€í™˜
    job_type_map = {'ë””ì§€í„¸/ì›ê²©': 'digital', 'ì§€ì—­ ê¸°ë°˜(ë†ì—…/ê´€ê´‘)': 'local', 'ê³µê³µ/ì‚¬íšŒì„œë¹„ìŠ¤': 'public'}
    job_type_val = job_type_map[job_type_display]
    community_val = community_labels.index(community_display) + 1

# ---------------------------------
# í•µì‹¬ ë¡œì§: ì§€ì—­ ì¶”ì²œ
# ---------------------------------
# ì§ë¬´ ìœ í˜•ìœ¼ë¡œ 1ì°¨ í•„í„°ë§
filtered_regions = region_df[region_df['job_tags'].apply(lambda x: job_type_val in x)].copy()
# ì˜ˆì‚°ìœ¼ë¡œ 2ì°¨ í•„í„°ë§
filtered_regions = filtered_regions[filtered_regions['budget'] <= budget]

# í•„í„°ë§ëœ ê²°ê³¼ê°€ ì—†ìœ¼ë©´ ì˜ˆì‚° ì¡°ê±´ë§Œìœ¼ë¡œ ë‹¤ì‹œ í•„í„°ë§
if filtered_regions.empty:
    filtered_regions = region_df[region_df['budget'] <= budget].copy()
# ê·¸ë˜ë„ ì—†ìœ¼ë©´ ì „ì²´ ì§€ì—­ì„ ëŒ€ìƒìœ¼ë¡œ í•¨
if filtered_regions.empty:
    filtered_regions = region_df.copy()

scores = []
for index, row in filtered_regions.iterrows():
    community_diff = abs(row['community'] - community_val)
    # ì ìˆ˜ ê³„ì‚°: ì»¤ë®¤ë‹ˆí‹° ì í•©ë„ 40%, ì¼ìë¦¬ ì ìˆ˜ 60%
    score = (5 - community_diff) * 0.4 + row['scores']['ì¼ìë¦¬'] * 0.6
    scores.append(score)

filtered_regions['final_score'] = scores
best_region = filtered_regions.loc[filtered_regions['final_score'].idxmax()]


# ---------------------------------
# ê²°ê³¼ ë””ìŠ¤í”Œë ˆì´
# ---------------------------------
st.header("ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼")
st.subheader(f"ë‹¹ì‹ ì˜ ì¡°ê±´ì— ê°€ì¥ ì í•©í•œ ì¶”ì²œ ì§€ì—­ì€ **:blue[{best_region['name']}]** ì…ë‹ˆë‹¤.")

col1, col2 = st.columns(2)

with col1:
    st.markdown("##### ì¢…í•© ì •ì°© ì ìˆ˜")
    # Plotly ë ˆì´ë” ì°¨íŠ¸
    radar_fig = go.Figure()
    radar_fig.add_trace(go.Scatterpolar(
          r=list(best_region['scores'].values()),
          theta=list(best_region['scores'].keys()),
          fill='toself',
          name='ì •ì°© ì í•©ë„'
    ))
    radar_fig.update_layout(
      polar=dict(
        radialaxis=dict(
          visible=True,
          range=[0, 5]
        )),
      showlegend=False,
      height=400,
      margin=dict(l=50, r=50, t=50, b=50) # ì—¬ë°± ì¡°ì •
    )
    st.plotly_chart(radar_fig, use_container_width=True)

with col2:
    st.markdown("##### ì˜ˆìƒ ì›”ë³„ ìˆ˜ì…/ì§€ì¶œ")
    income = (best_region['scores']['ì¼ìë¦¬'] / 5) * 400 + 150
    finance_data = {
        "ê¸ˆì•¡ (ë§Œì›)": [income, best_region['budget']]
    }
    finance_df = pd.DataFrame(finance_data, index=["ì˜ˆìƒ ìˆ˜ì…", "ì˜ˆìƒ ì§€ì¶œ"])
    st.bar_chart(finance_df, height=400)


st.divider()

# --- ì¶”ê°€ ì •ë³´ ì„¹ì…˜ ---
tab1, tab2, tab3 = st.tabs(["ğŸ ì˜ˆìƒ ìˆ˜í˜œ ê°€ëŠ¥ í˜œíƒ", "âœ¨ ì¶”ì²œ ì¼ìë¦¬ ë§¤ì¹­", "ğŸ¤– AI ì¸ì‚¬ì´íŠ¸"])

with tab1:
    st.subheader(f"{best_region['name']}ì—ì„œ ë°›ì„ ìˆ˜ ìˆëŠ” í˜œíƒ")
    matched_benefits = benefits_df[benefits_df['region_id'] == best_region['id']]
    if not matched_benefits.empty:
        for index, row in matched_benefits.iterrows():
            with st.expander(f"**[{row['category']}]** {row['name']}"):
                st.write(row['description'])
    else:
        st.info("ì´ ì§€ì—­ì— ëŒ€í•œ ë§ì¶¤í˜• í˜œíƒ ì •ë³´ê°€ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.")


with tab2:
    st.subheader("ë‚˜ë¥¼ ìœ„í•œ ì¶”ì²œ ì¼ìë¦¬ Top 3")
    # job_dfì˜ ë³µì‚¬ë³¸ì„ ë§Œë“¤ì–´ ì‘ì—…í•˜ì—¬ SettingWithCopyWarning ë°©ì§€
    jobs_to_match = job_df.copy()

    # ë””ì§€í„¸ ì§ë¬´ëŠ” ì§€ì—­ ìƒê´€ì—†ì´, ê·¸ ì™¸ ì§ë¬´ëŠ” ì§€ì—­ ì¼ì¹˜ ì¡°ê±´
    is_digital_remote = (jobs_to_match['type'] == 'digital') & jobs_to_match['region_id'].isnull()
    is_local_match = jobs_to_match['region_id'] == best_region['id']

    matched_jobs = jobs_to_match[(jobs_to_match['type'] == job_type_val) & (is_digital_remote | is_local_match)]

    if not matched_jobs.empty:
        suitability_scores = []
        for idx, job in matched_jobs.iterrows():
            score = job['base_score']
            if community_val >= 4 and best_region['community'] >= 4:
                score += 5
            if budget > best_region['budget'] + 50:
                score += 3
            suitability_scores.append(min(99, score))

        matched_jobs['suitability'] = suitability_scores
        top3_jobs = matched_jobs.sort_values(by='suitability', ascending=False).head(3)

        for idx, job in top3_jobs.iterrows():
            st.markdown(f"**{job['name']}**")
            st.progress(job['suitability'], text=f"ì í•©ë„: {job['suitability']}%")
    else:
        st.info("í˜„ì¬ ì¡°ê±´ì— ë§ëŠ” ì¶”ì²œ ì¼ìë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.")

with tab3:
    st.subheader("AIì—ê²Œ ë” ìì„¸í•œ ì •ë³´ ì–»ê¸°")

    if not api_key:
        st.warning("AI ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ ì‚¬ì´ë“œë°”ì— Google Gemini API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    else:
        if st.button("âœ¨ AI ì •ì°© ì»¨ì„¤í„´íŠ¸ì—ê²Œ ì¡°ì–¸ë°›ê¸°"):
            with st.spinner("AIê°€ ë‹¹ì‹ ì„ ìœ„í•œ ì¡°ì–¸ì„ ìƒì„± ì¤‘ì…ë‹ˆë‹¤..."):
                prompt = f"""
                ë‹¹ì‹ ì€ ì¹œì ˆí•˜ê³  ì§€ì‹ì´ í’ë¶€í•œ ì •ì°© ì»¨ì„¤í„´íŠ¸ì…ë‹ˆë‹¤.
                í•œ ì‚¬ìš©ìê°€ '{best_region['name']}'ìœ¼ë¡œì˜ ì´ì£¼ë¥¼ ê³ ë ¤í•˜ê³  ìˆìŠµë‹ˆë‹¤.
                ì´ ì§€ì—­ì˜ íŠ¹ì§•ì€ {best_region['scores']} (5ì  ë§Œì ) ì…ë‹ˆë‹¤.
                ì‚¬ìš©ìì˜ í”„ë¡œí•„ì€ ì›” ì˜ˆì‚° {budget}ë§Œì›, í¬ë§ ì§ë¬´ '{job_type_display}', ì»¤ë®¤ë‹ˆí‹° ì„ í˜¸ë„ '{community_display}'ì…ë‹ˆë‹¤.
                ì´ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ, í•´ë‹¹ ì§€ì—­ì—ì„œì˜ ì‚¶ì´ ì–´ë–¨ì§€ì— ëŒ€í•´ í˜„ì‹¤ì ì´ë©´ì„œë„ ê²©ë ¤ê°€ ë˜ëŠ” ì§§ì€ ë‹¨ë½(3~4ë¬¸ì¥)ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.
                ì‚¬ìš©ìì˜ í”„ë¡œí•„ì— ë§ì¶° ì¥ë‹¨ì ì„ ì–¸ê¸‰í•´ì£¼ì„¸ìš”.
                """

                payload = {"contents": [{"role": "user", "parts": [{"text": prompt}]}]}
                api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={api_key}"

                try:
                    response = requests.post(api_url, json=payload, headers={'Content-Type': 'application/json'})
                    response.raise_for_status()
                    result = response.json()

                    if 'candidates' in result and result['candidates']:
                        st.success(result['candidates'][0]['content']['parts'][0]['text'])
                    else:
                        st.error(f"AIë¡œë¶€í„° ìœ íš¨í•œ ì‘ë‹µì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. API ì‘ë‹µ: {result}")
                except requests.exceptions.RequestException as e:
                    st.error(f"API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
                except Exception as e:
                    st.error(f"ì‘ë‹µ ì²˜ë¦¬ ì¤‘ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")

        if st.button("âœ¨ ë‚˜ë§Œì˜ ì •ì°© ê³„íš ì´ˆì•ˆ ë°›ê¸°"):
            with st.spinner("ë§ì¶¤í˜• ê³„íšì„ ìƒì„± ì¤‘ì…ë‹ˆë‹¤..."):
                prompt = f"""
                '{best_region['name']}'ìœ¼ë¡œ ì´ì£¼ë¥¼ ê³„íšì¤‘ì¸ ì‚¬ëŒì„ ìœ„í•œ 5ë‹¨ê³„ ì •ì°© ê³„íš ì´ˆì•ˆì„ ìƒì„±í•´ì¤˜.
                ì´ ì‚¬ëŒì˜ í”„ë¡œí•„ì€ ì›” ì˜ˆì‚° {budget}ë§Œì›, í¬ë§ ì§ë¬´ '{job_type_display}', ì»¤ë®¤ë‹ˆí‹° ì„ í˜¸ë„ '{community_display}'ì´ì•¼.
                ê° ë‹¨ê³„ëŠ” ì‹¤ì§ˆì ì´ê³  ì‹¤í–‰ ê°€ëŠ¥í•´ì•¼ í•˜ë©°, í”„ë¡œí•„ì— ë§ì¶° ê°œì¸í™” ë˜ì–´ì•¼ í•´.
                """

                schema = {
                    "type": "OBJECT",
                    "properties": {
                        "plan": {
                            "type": "ARRAY",
                            "items": {
                                "type": "OBJECT",
                                "properties": {"task": {"type": "STRING"},"reason": {"type": "STRING"}},
                                "required": ["task", "reason"]
                            }
                        }
                    },
                    "required": ["plan"]
                }

                payload = {
                    "contents": [{"role": "user", "parts": [{"text": prompt}]}],
                    "generationConfig": { "responseMimeType": "application/json", "responseSchema": schema }
                }
                api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={api_key}"

                try:
                    response = requests.post(api_url, json=payload, headers={'Content-Type': 'application/json'})
                    response.raise_for_status()
                    result = response.json()

                    if 'candidates' in result and result['candidates']:
                        plan_data = json.loads(result['candidates'][0]['content']['parts'][0]['text'])
                        for i, item in enumerate(plan_data.get('plan', [])):
                            st.markdown(f"**{i+1}ë‹¨ê³„. {item['task']}**")
                            st.caption(f"ì´ìœ : {item['reason']}")
                    else:
                        st.error(f"AIë¡œë¶€í„° ìœ íš¨í•œ ê³„íšì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. API ì‘ë‹µ: {result}")
                except requests.exceptions.RequestException as e:
                    st.error(f"API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
                except json.JSONDecodeError:
                    st.error("AIê°€ ë³´ë‚¸ ì‘ë‹µì„ íŒŒì‹±í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
                except Exception as e:
                    st.error(f"ì‘ë‹µ ì²˜ë¦¬ ì¤‘ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
